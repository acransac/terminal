# Introduction
**terminal** provides a model to make terminal user interfaces. The user sees a _display_ which is either an _atom_ or a _list_ of displays. An atomic element of a display is a possibly labelled bordered box with textual content. Using streamer(LINK), a display can react to events generated by the user or the environment.

**terminal** benefits from the high-level modelling of terminal graphics as a tree introduced by Blessed(LINK). It also borrows its tools and terminology from the Lisp family of programming languages.

# How To Use Terminal
Add **terminal** to a project with:

```shell
    $ npm install @acransac/terminal
```

and import the needed functionalities:

```javascript
    const { atom, column, compose, cons, emptyList, indent, inline, label, renderer, row, show, sizeHeight, sizeWidth, TerminalTest, vindent } = require('@acransac/streamer');
```

## Make An Inert Atomic Display
The rendering engine is initialized with `renderer`. The latter returns function handles to render a display and terminate the engine. An atomic display is created with `atom` and passed to the render handle. Then, the engine is terminated:
* `renderer:: Maybe<Stream.Writable> -> (Display -> IO (), () -> IO ())`
  | Parameter / Returned | Type                            | Description             |
  |----------------------|---------------------------------|-------------------------|
  | output               | Maybe\<Stream.Writable>         | A writable Node.js stream to which the displayed characters and escape sequences are written. Default: `process.stdout` |
  | _returned_           | (Display -> IO (), () -> IO ()) | An array of two functions. The first renders on the output the display passed as argument. The second tears down the rendering system |
* `atom:: String -> Display`
  | Parameter | Type   | Description                           |
  |-----------|--------|---------------------------------------|
  | content   | String | The text to print within the atom box |

Example:

```javascript
    const { atom, renderer } = require('@acransac/terminal');

    const [render, terminate] = renderer();

    render(atom("abc"));

    setTimeout(terminate, 2000);
```

```shell
    $ node example.js
```
(SCREENSHOT)

## Make An Inert List Display
As mentioned before, **terminal**'s tooling inherits the fundamental notions of the Lisp dialects. A display is a recursive structure expressed as nested lists of displays. It is built by `cons`'ing displays onto lists, ending such ramified chains with the `emptyList`:
* `cons:: (Display, List<Display>) -> List<Display>`
  | Parameter | Type           | Description                           |
  |-----------|----------------|---------------------------------------|
  | display   | Display        | The display, atom or list, to prepend |
  | list      | List\<Display> | The list of displays to prepend to    |

* `emptyList:: () -> List<Display>`
  | Returned  | Type           | Description                                                                                |
  |-----------|----------------|--------------------------------------------------------------------------------------------|
  | _returned_| List\<Display> | A list display printing nothing. The starting point to which useful displays are prepended |

Example:

```javascript
    const { atom, cons, emptyList, renderer } = require('@acransac/terminal');

    const [render, terminate] = renderer();

    render(cons(atom("abc"), emptyList()));

    setTimeout(terminate, 2000);
```

```shell
    $ node example.js
```
(SCREENSHOT)
