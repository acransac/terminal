# Introduction
**terminal** provides a model to make terminal user interfaces. The user sees a _display_ which is either an _atom_ or a list of displays. An atomic element of a display is a possibly labelled bordered box with textual content. Using streamer(LINK), a display can react to events generated by the user or the environment.

**terminal** benefits from the high-level modelling of terminal graphics as a tree introduced by Blessed(LINK). It also borrows its vocabulary from the Lisp family of programming languages' terminology.

# How To Use Terminal
Add **terminal** to a project with:

```shell
    $ npm install @acransac/terminal
```

and import the needed functionalities:

```javascript
    const { atom, column, compose, cons, emptyList, indent, inline, label, renderer, row, show, sizeHeight, sizeWidth, TerminalTest, vindent } = require('@acransac/streamer');
```

## Make An Inert Atomic Display
The rendering engine is initialized with `renderer`. The latter returns function handles to render a display and terminate the engine. An atomic display is created with `atom` and passed to the render handle. Then, the engine is terminated:
* `renderer:: Maybe<Stream.Writable> -> (Display -> IO (), () -> IO ())`
  | Parameter / Returned | Type                            | Description             |
  |----------------------|---------------------------------|-------------------------|
  | output               | Maybe\<Stream.Writable>         | A writable Node.js stream to which the displayed characters and escape sequences are written. Default: `process.stdout` |
  | _returned_           | (Display -> IO (), () -> IO ()) | An array of two functions. The first renders on the output the display passed as argument. The second tears down the rendering system |
* `atom:: `
